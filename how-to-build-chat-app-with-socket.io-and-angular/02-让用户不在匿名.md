## 让用户不在匿名

### 添加登录页面

简单起见，我们要求用户使用gmail登录，通过gmail可以拿到用户的avatar头像。在此之前我们先对前端代码进行了一下重构，从technode.js中，将组件拆了出来，便于代码维护。

拆了之后前端的结构如下：

```
static
├── components
│   ├── angular
│   ├── bootstrap
│   └── jquery
├── controllers
│   ├── message-creator.js
│   └── room.js
├── directives
│   ├── auto-scroll-to-bottom.js
│   └── ctrl-enter-break-line.js
├── index.html
├── services
│   └── socket.js
├── styles
│   └── room.css
└── technode.js
```

接下来，我们使用angular的router组件，将app分成两个页面：

- `/` 聊天室
- `/login` 登录页，让用户输入gmail登录

首先，安装angular-router：

```
bower install angular-route --save 
```

在index.html中引入angular-route：

```
<script type="text/javascript" src="/components/angular/angular.js"></script>
<script type="text/javascript" src="/components/angular-route/angular-route.js"></script>
```

在technode.js中添加对angular-route的依赖，引入router组件：

```
angular.module('techNodeApp', ['ngRoute'])
```

新建router.js，声明对router的处理：

```
angular.module('techNodeApp').config(function($routeProvider, $locationProvider) {
  $locationProvider.html5Mode(true);
  $routeProvider.
  when('/', {
    templateUrl: '/pages/room.html',
    controller: 'RoomCtrl'
  }).
  when('/login', {
    templateUrl: '/pages/login.html',
    controller: 'LoginCtrl'
  }).
  otherwise({
    redirectTo: '/login'
  })
})
```

我们采用html5的pushState来实现路由机制；接下来我们需要把room项目的html从index.html拆出来放到room.html中，供angular调用；

```
<div class="col-md-12">
  <div class="panel panel-default room">
    <div class="panel-heading room-header">TechNode</div>
    <div class="panel-body room-content">
      <div class="list-group messages" auto-scroll-to-bottom>
        <div class="list-group-item message" ng-repeat="message in messages">
          某某: {{message}}
        </div>
      </div>
      <form class="message-creator" ng-controller="MessageCreatorCtrl">
        <div class="form-group">
          <textarea required class="form-control message-input" ng-model="newMessage" ctrl-enter-break-line="createMessage()" placeholder="Ctrl+Enter to quick send"></textarea>
        </div>
      </form>
    </div>
  </div>
</div>
```

在index.html中，放一个占位，angular会更具url的不同载入不同的page，使用不同的controller；

```
<div class="container" style="margin-top:100px;">
  <div class="row" ng-view>
</div>
```

接下来，加入login.html，开始设计TechNode的登陆页吧！

```
<form class="form-inline">
  <div class="form-group">
    <label class="sr-only">Gmail</label>
    <input type="email" required class="form-control" placeholder="Gmail Account" />
  </div>
  <button type="submit" class="btn btn-primary btn-enter">Enter</button>
</form>
```

这个页面非常简单，就是一个表单，让用户提交gmail账号；

### 用户登录与认证

因为我们是一个单页面的应用程序，因此我们使用Ajax来实现用户登录和认证；首先添加一个全局的controller MainCtrl，用于用户是否登录的检测，如果未登录则跳转至登陆页。

index.html

```
<body ng-controller="MainCtrl">
  ...
</body>
```

/controllers/main.js

```
angular.module('techNodeApp').controller('MainCtrl', function($scope, $http, $location) {
  $http({
    url: '/ajax/validate',
    method: 'GET'
  }).success(function (user) {

  }).error(function (data) {
    $location.path('/login')
  })
})
```

通过ajax获取用户的信息，如果没有获取到，就意味着用户还没有登录，打开登录页面；来看看服务端怎么实现。

为了便于实现，我们在服务端采用mongodb来存储登录用户的信息；我们使用mongoose来操作mongodb，首先定义user的scheme：

新建models文件夹，创建user.js和index.js文件：

user.js:

```
var mongoose = require('mongoose')
var Schema = mongoose.Schema

var User = new Schema({
  email: String,
  name: String,
  avatar: String
});

module.exports = User
```

用户输入email，我们通过解析用户的email获取name和avatar头像地址；再来看看index.js文件：

```
var mongoose = require('mongoose')
mongoose.connect('mongodb://localhost/technodechapter02')
exports.User = mongoose.model('User', require('./user'))
```

我们使用mongoose来访问mongodb，使用user的scheme生成模型User，记得使用`npm install mongoose --save`安装mongoose；

接下来我们就要编写验证的逻辑了，新建controllers文件夹，新建user.js文件，为了便于管理代码，我们把user的业务逻辑都放在controller/user.js这个文件中；

```
var db = require('../models')
var async = require('async')
var gravatar = require('gravatar')

exports.findUserById = function (_userId, callback) {
  db.User.findOne({
    _id: _userId
  }, callback)
}

exports.findByEmailOrCreate = function (email, callback) {
  db.User.findOne({
    email: email
  }, function (err, user) {
    if (user) {
      callback(null, user)
    } else {
      user = new db.User
      user.name = email.split('@')[0]
      user.email = email
      user.avatarUrl = gravatar.url(email)
      user.save(callback)
    }
  })
}
```

我们实现了两个接口，一个是通过id查找用户，一个是通过email查找，如果没找到就根据email创建一个新账户，头像地址使用gravatar来生成；

来看看Ajax接口的实现：

```
// ...
var Controllers = require('./controllers')

app.use(express.bodyParser())
app.use(express.cookieParser())
app.use(express.session({
  secret: 'technode',
  cookie:{
    maxAge: 60 * 1000
  }
}))

// ...

app.get('/ajax/validate', function (req, res) {
  _userId = req.session._userId
  if (_userId) {
    Controllers.User.findUserById(_userId, function (err, user) {
      if (err) {
        res.json(401, {msg: err})
      } else {
        res.json(user)
      }
    })
  } else {
    res.json(401, null)
  }
})

app.post('/ajax/login', function (req, res) {
  email = req.body.email
  if (email) {
    Controllers.User.findByEmailOrCreate(email, function(err, user) {
      if (err) {
        res.json(500, {msg: err})
      } else {
        req.session._userId = user._id
        res.json(user)
      }
    })
  } else {
    res.josn(403)
  }
})

app.get('/ajax/logout', function (req, res) {
  req.session._userId = null
  res.json(401)
})
// ...
```

我们使用express提供的session模块来管理用户的认证，整个认证过程是这样的：

- 客户端调用validate测试用户是否登录，服务端查看在会话（session）中是否已经保存了用户的_userId，如果是则表示用户已经登录了，从数据库江用户信息读出来；发给客户端；
- 如果会话中没有用户Id，即用户未登录，客户端则通过login接口登录，服务端根根据用户填写的email地址到mongodb中查找用户，如果查找不到就创建一个新用户，然后把用户Id保存在session中，返回用户信息给客户端，登录成功；
- 还提供了一个logout的ajax接口，即简单清除了session中用户id，则用户在页面刷新验证时必须再次登录才行；

到此，整个服务端的逻辑完成了，来看看客户端

回到登录页面login.html：

```
<form class="form-inline" ng-submit="login()">
  <div class="form-group">
    <label class="sr-only">Gmail</label>
    <input type="email" required class="form-control" ng-model="email" placeholder="Gmail Account" />
  </div>
  <button type="submit" class="btn btn-primary btn-enter">Enter</button>
</form>
```

添加了一个submit的处理，在input上绑定了一个email，变量，看到LoginCtrl之后，它们的功能你就一幕了然了：

```
angular.module('techNodeApp').controller('LoginCtrl', function($scope, $http, $location) {
  $scope.login = function () {
    $http({
      url: '/ajax/login',
      method: 'POST',
      data: {
        email: $scope.email
      }
    }).success(function (user) {
      $scope.$emit('login', user)
      $location.path('/')
    }).error(function (data) {
      $location.path('/login')
    })
  }
})
```
即当用户输入了email之后，提交表单时，就调用controller的login方法，该方法将email发送给服务端，发起login的ajax请求；登录成功就跳转到聊天室`/`；

`$scope.$emit('login', user)`是干什么用户的呢，我们先来看看MainCtrl了实现就一幕了然了；

首先在页面导航的右上角，显示用户的头像和登出链接：

```
<nav class="collapse navbar-collapse" role="navigation">
  <ul class="nav navbar-nav navbar-right" ng-show="me">
    <li>
      <img src="{{me.avatarUrl}}" title="{{me.name}}" class="img-rounded"/>
    </li>
    <li>
      <a href="" ng-click="logout()">Log out</a>
    </li>
  </ul>
</nav>
```

如果变量me为真，即如果存在用户信息就显示用户头像和登出了解，否则什么也不显示；

最后来看看MainCtrl：

```
angular.module('techNodeApp').controller('MainCtrl', function($scope, $http, $location) {
  $http({
    url: '/ajax/validate',
    method: 'GET'
  }).success(function (user) {
    $scope.me = user
    $location.path('/')
  }).error(function (data) {
    $location.path('/login')
  })
  $scope.logout = function() {
    $http({
      url: '/ajax/logout',
      method: 'GET'
    }).success(function () {
      $scope.me = null
      $location.path('/login')
    })
  }

  $scope.$on('login', function (evt, me) {
    $scope.me = me
  })
})
```

MainCtrl做了三个事情：

- 因为MainCtrl是一个全局的Controller，即在每次页面刷新时，都会调用这个模块，因此我们用来做权限验证的关口。在每次页面刷新时都通过ajax调用validate接口，查看用户是否已经登录，如果登录了，就将用户信息赋值给me，由于angular的双向绑定，用户头像就会显示出来；
- 提供了一个logout函数，当用户点击登出链接时，就会通过ajax调用服logout接口，将用户会话中的用户id清除，同时清除客户端的用户信息`$scope.me = null`，将页面跳转至登录页；
- MainCtrl还通过$scope.$on监听着来自子域LoginCtrl的login事件，即当用户通过登陆页登录成功后，将用户信息发送给MainCtrl，更新用户信息；至于为什么需要这样做，这和angular的scope原理相关，大家可以查看相关资料了解。

#### socket.io认证

除了每次页面刷新时通过ajax认证之外，我们还需要对socket访问进行认证；socket.io提供了认证的接口，只需要我们简单配置一下即可：

```
// ...
var parseSignedCookie = require('connect').utils.parseSignedCookie
var MemoryStore = require('connect').session.MemoryStore
var Cookie = require('cookie')

var sessionStore = new MemoryStore()

app.use(express.bodyParser())
app.use(express.cookieParser())
app.use(express.session({
  secret: 'technode',
  cookie: {
    maxAge: 60 * 1000
  },
  store: sessionStore
}))

// ...

var io = require('socket.io').listen(app.listen(port))

io.set('authorization', function(handshakeData, accept) {
  handshakeData.cookie = Cookie.parse(handshakeData.headers.cookie)
  var connectSid = handshakeData.cookie['connect.sid']
  connectSid = parseSignedCookie(connectSid, 'technode')

  if (connectSid) {
    sessionStore.get(connectSid, function(error, session) {
      if (error) {
        accept(error.message, false)
      } else {
        handshakeData.session = session
        if (session._userId) {
          accept(null, true)
        } else {
          accept('No login')
        }
      }
    })
  } else {
    accept('No session')
  }
})
```

我们通过io.set('authorization',callback)这个接口进行认证，手动解析了客户端的session数据，如果找到session且session中存在用户信息的话，认证成功，否则认证失败；
在这里引入了connnect和cookie两个类库，别忘了使用npm安装；
还有，我们把session的存储对象暴露了出来，我们才得以在socket认证的过程中手动解析出session。

到此我们用户认证完成了，用户可以通过email登录，也可以退出，在用户登录后，我们可以拿到用户的信息，这样在用户发送消息时，我们就可以显示用户名啦！

### 显示用户名和在线用户列表

#### 显示用户名

修改room.html中的模板，添加用户名和用户头像：

```
<div class="col-md-12">
  <div class="panel panel-default room">
    <div class="panel-heading room-header">TechNode</div>
    <div class="panel-body room-content">
      <div class="list-group messages" auto-scroll-to-bottom>
        <div class="list-group-item message" ng-repeat="message in messages">
          <img src="{{message.creator.avatarUrl}}" title="{{message.creator.name}}" class="img-rounded"/>
          {{message.creator.name}}: {{message.message}}
        </div>
      </div>
      <form class="message-creator" ng-controller="MessageCreatorCtrl">
        <div class="form-group">
          <textarea required class="form-control message-input" ng-model="newMessage" ctrl-enter-break-line="createMessage()" placeholder="Ctrl+Enter to quick send"></textarea>
        </div>
      </form>
    </div>
  </div>
</div>
```

在用户发送消息时，将用户信息记录下来：

```
angular.module('techNodeApp').controller('MessageCreatorCtrl', function($scope, socket) {
  $scope.createMessage = function () {
    socket.emit('messages.create', {
      message: $scope.newMessage,
      creator: $scope.me
    })
    $scope.newMessage = ''
  }
})
```

在这里我们发送的消息不在是一个字符串，而是一个携带了用户信息的json对象；

重启服务器，登录发条消息，终于，TechNode的用户不再是匿名的了！
