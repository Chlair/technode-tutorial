## 架构优化与发布

在本章中，我们将对前三章中一步步编写出来聊天室重新做一次梳理，进行一些优化，让整个项目更容易理解和扩展。其次我们还会介绍一些前端流行的工具，帮助我们构建项目，便于发布。

### 目前的项目结构

目前整个项目的架构如下图：

![TechNode Structure](./examples/chapter04/images/TechNodestructure.png)

箭头代表了读取数据的流向，服务端和客户端基本上都分为三层：

- 服务端：在mongodb和mongoose之上，我们添加了一层模型的controller，这一层直接处理一些业务相关的逻辑；在这之上，我们直接通过http API或者socket.io将所提供的接口暴露出来；这一块的代码我们全部写在了app.js中；
- 客户端：针对不同的组件或者页面，我们对应了不同的controller，而这些controller都是通过$http或者socket service直接于服务端通信的；各个controller之间共享数据很困难。

总结一下：

- 将服务端的service逻辑从app.js分拆到http和socket service中
- 在客户端提供一个统一的数据接口层，向上为controller提供数据服务，向下和服务端通信，同步数据。

新的结构应该像下面这样：

![TechNode Structure](./examples/chapter04/images/TechNodestructurenew.png)

### 分拆http和socket服务

首先简化app.js：

```
// ...

var api = require('./services/api')
var socketApi = require('./services/socketApi')

// ...

app.post('/api/login', api.login)
app.get('/api/logout', api.logout)
app.get('/api/validate', api.validate)

// ...

io.sockets.on('connection', function(socket) {

  socketApi.connect(socket)

  socket.on('disconnect', function() {
    socketApi.disconnect(socket)
  })

  socket.on('technode', function(request) {
    socketApi[request.action](request.data, socket, io)
  })
})

// ...
```

我们把http和socket的回调分别放到api.js和socketApi.js中，在socket通信方面做了简化，使用`technode`作为统一的事件名，而需要调用的接口名，则由请求数据中的`action`来决定。每个socket请求都会变成下面这样：

客户端的请求：

```
socket.emit('technode', {
  action: 'getRoom'
})
```

下面是服务端的返回：

```
socket.emit('technode', {
  "action": "getRoom",
  "data": [{
    "name": "Socket.IO",
    "_id": "52b0e5dd0a5e66fa26000001",
    "__v": 0,
    "createAt": "2013-12-18T00:01:33.528Z",
    "users": [],
    "messages": []
  }]
})
```

客户端则根据action，进行不同的处理：

```
socket.on('technode', function (data) {
  switch (data.action) {
      // ...
  }
})
```

而本身api.js和socketApi.js内的处理，与第三章的基本无异，不再细说。

### 客户端缓存

为什么需要客户端缓存？有两点原因：

1. 在第三章的实现中，在房间列表和房间切换时，controller都会通过socket从服务端重新获取房间列表或房间；
2. 在第三章的实现中，我们无法在controller之间共享数据，比如在LoginCtrl中，用户登录后，我们需要更$rootScope的用户信息，我们采用了scope事件机制来实现。

我们需要一个缓存数据和共享数据的组件，这个组件将服务端请求来的数据缓存下来，避免重复的从服务端请求相同的数据，其次是对所有的controller提供接口，让controller可以共享（读取、修改）同一块数据。

我们把这个组件命名为server，与服务端通信完全通过这个组件，数据缓存到这个组件之中，controller直接与它通信，不必关系正真的服务器是什么样的。

```
angular.module('techNodeApp').factory('server', ['$cacheFactory', '$q', '$http', 'socket', function($cacheFactory, $q, $http, socket) {
  var cache = window.cache = $cacheFactory('technode')
  socket.on('technode', function(data) {
    switch (data.action) {
      case 'getRoom':
        if (data._roomId) {
          angular.extend(cache.get(data._roomId), data.data)
        } else {
          data.data.forEach(function (room) {
            cache.get('rooms').push(room)
          })
        }
        break
      // case something else
      // handle for socket events
    }
  })

  socket.on('err', function (data) {
    // handle server err
  })

  return {
    validate: function() {
      var deferred = $q.defer()
      $http({
        url: '/api/validate',
        method: 'GET'
      }).success(function(user) {
        angular.extend(cache.get('user'), user)
        deferred.resolve()
      }).error(function(data) {
        deferred.reject()
      })
      return deferred.promise
    }
    // more API
  }
}])
```

在server中，我们使用两个Angular.js提供的组件，`$q`和`$cacheFactory`。

#### $q

$q是Angular.js对JavaScript异步变成模式Promise的实现，参考了https://github.com/kriskowal/q。在TechNode对它的用法相对比较简单，仅仅是将ajax请求隐藏起来。以server.validate为例：


```
validate: function() {
  var deferred = $q.defer()
  $http({
    url: '/api/validate',
    method: 'GET'
  }).success(function(user) {
    angular.extend(cache.get('user'), user)
    deferred.resolve()
  }).error(function(data) {
    deferred.reject()
  })
  return deferred.promise
}
```

`$q.defer()`获取一个differed（推迟）对象，然后`return deferred.promise`先返回promise（承诺），在服务器端成功返回后，resolve（兑现）承诺，或者遇到问题，reject（拒绝）兑现。

在technode.js中我们可以这样使用：

```
server.validate().then(function() {
  if ($location.path() === '/login') {
    $location.path('/rooms')
  }
}, function() {
  $location.path('/login')
})
```

`server.validate()`获取promise（承诺）对象，then(resolvedCallback, rejectCallack)（然后）根据承诺的兑现情况进行不同的处理。

换句话说，technode.js中的`techNodeApp`问server，用户是不是登录了，server必须调用服务端接口进行验证，因此server给`techNodeApp`许诺，`techNodeApp`则只需要针对许诺是否兑现进行处理就好了。

所有与http请求相关的接口，我们都做了相似的处理。

#### $cacheFactory

$cacheFactory是Angular提供的缓存组件，该组件直接将数据存放在内存中。

```
var cache = window.cache = $cacheFactory('technode')

// ...

cache.put('rooms', [])

// ...

cache.get('rooms') && cache.get('rooms').forEach(function(room) {
  if (room._id === _roomId) {
    room.users = room.users.filter(function(user) {
      return user._id !== _userId
    })
  }
})
```

直接调用$cacheFactory，传入cacheId，Angular就为我构造出一块缓存区域，我们就可以通过get、put等等方法来存储或者获取缓存数据了。

$cacheFactory提供了一种TechNode中未使用的特性，即这块缓存可以是LRU的，即这块缓存是有大小的（避免缓存太大了，影响了性能），并且这块缓存使用LRU算法来淘汰长时间未使用的数据。

### controller与server

有了server，我们来看看controller有合变化？这是原来的RoomCtrl的代码：

```
angular.module('techNodeApp').controller('RoomCtrl', function($scope, $routeParams, $scope, socket) {
  socket.on('rooms.read.' + $routeParams._roomId, function(room) {
    $scope.room = room
  })
  socket.emit('rooms.read', {
    _roomId: $routeParams._roomId
  })
  socket.on('messages.add', function(message) {
    $scope.room.messages.push(message)
  })
  // ...
  socket.on('users.join', function (join) {
    $scope.room.users.push(join.user)
  })

  socket.on('users.leave', function(leave) {
    _userId = leave.user._id
    $scope.room.users = $scope.room.users.filter(function(user) {
      return user._id != _userId
    })
  })
})
```

这是基于server组件修改后的RoomCtrl：

```
angular.module('techNodeApp').controller('RoomCtrl', ['$scope', '$routeParams', '$scope', 'server', function($scope, $routeParams, $scope, server) {

  $scope.room = server.getRoom($routeParams._roomId)

  // ...
}])
```

- RoomCtrl不再直接于服务端通信读取当前的房间信息
- 无需监听用户进入或者离开，监听新消息

RoomCtrl只需调用server.getRoom，传入房间的id即可。那房间信息不是需要到服务端读取么？这是怎么实现的？

这完全得益于Angular数据绑定特性，即数据变化，视图也会跟着变化：

```
getRoom: function(_roomId) {
  if (!cache.get(_roomId)) {
    cache.put(_roomId, {
      users: [],
      messages: []
    })
    socket.emit('technode', {
      action: 'getRoom',
      data: {
        _roomId: _roomId
      }
    })
  }
  return cache.get(_roomId)
}
```

这里的处理方式与`promise`有异曲同工之妙，`getRoom`方法，如果在缓存中没有找到房间的数据，就先放入一个房间对象，不过里面的数据都是空的（此时，RoomCtrl渲染出来的是一个空的房间视图），然后通过socket向服务端请求房间数据；如果找到就直接返回从缓存中获取的房间数据，RoomCtrl就可以渲染出来一个正常的房间视图。

而在服务端返回房间信息后，

```
case 'getRoom':
  if (data._roomId) {
    angular.extend(cache.get(data._roomId), data.data)
  } else {
    data.data.forEach(function (room) {
      cache.get('rooms').push(room)
    })
  }
```

我们使用服务端的数据扩展空房间即可，Angular即根据数据的变化，渲染出新的房间视图。

> 我们必须保证更新的房间对象必须是视图绑定的对象，因此我们一开始就返回一个房间对象，后面只是修改这个对象的属性。

同理，RoomCtrl也无需出来用户进入或者离开房间，有新消息这类事件，因为server组件会自动更新对应的数据，RoomCtrl只需要按照数据渲染即可。

好了，我们利用客户端缓存和Angular数据绑定特性，大大简化了TechNode控制器层。到此，我们的开发之旅已经接近尾声，接下来，我们将学习如何将前端程序打包，发布！

### 使用Grunt打包TechNode















