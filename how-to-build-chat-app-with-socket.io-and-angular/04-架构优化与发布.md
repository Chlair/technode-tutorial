## 架构优化与发布

在本章中，我们将对前三章中一步步编写出来聊天室重新做一次梳理，进行一些优化，让整个项目更容易理解和扩展。其次我们还会介绍一些前端流行的工具，帮助我们构建项目，便于发布。

### 目前的项目结构

目前整个项目的架构如下图：

![TechNode Structure](./examples/chapter04/images/TechNodestructure.png)

箭头代表了读取数据的流向，服务端和客户端基本上都分为三层：

- 服务端：在mongodb和mongoose之上，我们添加了一层模型的controller，这一层直接处理一些业务相关的逻辑；在这之上，我们直接通过http API或者socket.io将所提供的接口暴露出来；这一块的代码我们全部写在了app.js中；
- 客户端：针对不同的组件或者页面，我们对应了不同的controller，而这些controller都是通过$http或者socket service直接于服务端通信的；各个controller之间共享数据很困难。

总结一下：

- 将服务端的service逻辑从app.js分拆到http和socket service中
- 在客户端提供一个统一的数据接口层，向上为controller提供数据服务，向下和服务端通信，同步数据。

新的结构应该像下面这样：

![TechNode Structure](./examples/chapter04/images/TechNodestructurenew.png)

### 分拆http和socket服务

首先简化app.js：

```
// ...

var api = require('./services/api')
var socketApi = require('./services/socketApi')

// ...

app.post('/api/login', api.login)
app.get('/api/logout', api.logout)
app.get('/api/validate', api.validate)

// ...

io.sockets.on('connection', function(socket) {

  socketApi.connect(socket)

  socket.on('disconnect', function() {
    socketApi.disconnect(socket)
  })

  socket.on('technode', function(request) {
    socketApi[request.action](request.data, socket, io)
  })
})

// ...
```

我们把http和socket的回调分别放到api.js和socketApi.js中，在socket通信方面做了简化，使用`technode`作为统一的事件名，而需要调用的接口名，则由请求数据中的`action`来决定。每个socket请求都会变成下面这样：

客户端的请求：

```
socket.emit('technode', {
  action: 'getRoom'
})
```

下面是服务端的返回：

```
socket.emit('technode', {
  "action": "getRoom",
  "data": [{
    "name": "Socket.IO",
    "_id": "52b0e5dd0a5e66fa26000001",
    "__v": 0,
    "createAt": "2013-12-18T00:01:33.528Z",
    "users": [],
    "messages": []
  }]
})
```

客户端则根据action，进行不同的处理：

```
socket.on('technode', function (data) {
  switch (data.action) {
      // ...
  }
})
```

而本身api.js和socketApi.js内的处理，与第三章的基本无异，不再细说。

### 客户端缓存

为什么需要客户端缓存？有两点原因：

1. 在第三章的实现中，在房间列表和房间切换时，controller都会通过socket从服务端重新获取房间列表或房间；
2. 在第三章的实现中，我们无法在controller之间共享数据，比如在LoginCtrl中，用户登录后，我们需要更$rootScope的用户信息，我们采用了scope事件机制来实现。

我们需要一个缓存数据和共享数据的组件，这个组件将服务端请求来的数据缓存下来，避免重复的从服务端请求相同的数据，其次是对所有的controller提供接口，让controller可以共享（读取、修改）同一块数据。







